<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用Hexo的常见命令</title>
    <link href="/2023/02/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/02/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="使用hexo的常见命令"><a href="#使用hexo的常见命令" class="headerlink" title="使用hexo的常见命令"></a>使用hexo的常见命令</h1><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 我的博客<br>date: 2023<span class="hljs-string">-02</span><span class="hljs-string">-16</span> 12:19:07<br>categories:<br>- [日常生活]<br><span class="hljs-keyword">tags:</span><br>- 生活<br></code></pre></td></tr></table></figure><p>如果你需要为文章添加多个分类，可以尝试List：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">categories</span>:<br><span class="hljs-literal">-</span> [Diary, PlayStation]<br><span class="hljs-literal">-</span> [Diary, Games]<br><span class="hljs-literal">-</span> [Life]<br></code></pre></td></tr></table></figure><p>以下是预先定义的参数:</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr></tbody></table><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。该命令可以简写为</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">个人博客的教程</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC 通信原理</title>
    <link href="/2023/02/17/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/02/17/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="传统-IPC-通信原理"><a href="#传统-IPC-通信原理" class="headerlink" title="传统 IPC 通信原理"></a>传统 IPC 通信原理</h1><p><strong>在操作系统中，进程与进程间的内存和数据都是不共享的</strong>。这样做的目的，是为了避免进程间相互操作数据的现象发生，从而引起各自的安全问题。为了实现进程隔离，采用了虚拟地址空间，两个进程各自的虚拟地址不同，从逻辑上来实现彼此间的隔离。两个进程之间要进行通信，就需要采用特殊的通信机制：进程间通信（IPC:Inter-Process Communication，即进程间通信或跨进程通信，简称 IPC）。</p><p><img src="https://img-blog.csdnimg.cn/5d182f4b99dc4edfa19e56c9a7ec7aef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="进程间的通信"></p><p>​一个进程空间分为用户空间和内核空间，用户空间是每个进程独有的，而内核空间则是所有进程间共有的。所以虽然不同进程的用户空间之间不能共享数据，但是我们可以通过内核空间来实现数据共享。</p><p>​数据在用户空间和内核空间之间的交互，需要调用系统方法：copy_from_user()和copy_to_user；数据拷贝2次，用户空间—&gt;&gt;内核空间—&gt;&gt;用户空间。</p><p><img src="https://img-blog.csdnimg.cn/1975c44081ee4b00a3f28fb157a3b34c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p><h1 id="Linux跨进程通信"><a href="#Linux跨进程通信" class="headerlink" title="Linux跨进程通信"></a>Linux跨进程通信</h1><p>Android系统就是基于Linux内核实现的，咱们先简单了解一下Linux系统的IPC方式。虽然不同的资料对各种方式的名称和种类说法不完全相同，但是主要来说有如下6种方式：（1）管道 Pipe；（2）信号Signal；（3）信号量Semaphore；（4）消息队列Message Queue；（5）共享内存Shared Memmory；（6）套接字Socket。</p><h1 id="Android跨进程通信"><a href="#Android跨进程通信" class="headerlink" title="Android跨进程通信"></a>Android跨进程通信</h1><p>Android 进程间通信可以通过Android 四大组件实现。</p><h2 id="1、Activity方式"><a href="#1、Activity方式" class="headerlink" title="1、Activity方式"></a>1、Activity方式</h2><p>Activity是四大组件中使用最频繁的，咱们先从它说起。使用Activity方式实现，就是使用startActivity()来启动另外一个进程的Activity。我们在使用App的使用，往往会遇到如下几种情形：</p><p>（1）浏览器中看到一篇比较不错的文章，分享到微信朋友圈或者微博；</p><p>（2）在某个App中点击某个网址，然后界面跳转到浏览器中进行阅读；</p><p>（3）使用美团外卖app，看到店家的电话，点击联系商家时，跳转到了电话拨打界面…</p><p>这些就是通过startActivity的方式从一个App，跳转到了另外一个App的Activity，从而实现了跨进程通信。</p><p>我们知道，在调用startActivity(Intent intent)的时候，intent有两个类型：显式Intent和隐式Intent。</p><p><strong>显式Intent的使用方式如下，用于进程内组件间通信</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,OtherActivity.class);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><p><strong>隐式intent的使用方式如下，用于IPC</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.setAction(Intent.ACTION_CALL);<br>startActivity(intent); <span class="hljs-comment">//startActivityForResult()同样，这里不赘述</span><br><br></code></pre></td></tr></table></figure><p>Intent.ACTION_CALL就是字符串常量“android.intent.action.CALL”，这种方式通过setAction的方式来启动目标app的Activity，上述代码就是启动电话app的拨号界面，有时候还可以带上电话号码等参数。由上可知，Activity实现跨进程通信的方式，适合于不同App之间功能界面的跳转。</p><h2 id="2、Content-provider（后面简称CP）方式"><a href="#2、Content-provider（后面简称CP）方式" class="headerlink" title="2、Content provider（后面简称CP）方式"></a>2、Content provider（后面简称CP）方式</h2><p>当我们开发App需要用到联系人，多媒体信息等数据的时候，往往会通过系统提供Uri，采用CP的方式去获取。Android系统中，数据主要存储在自带的SqlLite数据库中。应用要共享SqlLite中的数据给其他App操作（增、删、改、查），就要用到CP，也就是说，CP主要用于跨进程数据库共享。Android系统提供了很多的CP来供其它App使用，如多媒体信息、联系人、日历等。如下图显示了Android系统提供的CP，包名都是以”com.android.providers“开头的：</p><p>App开发者也可以自定义CP，把自己的数据提供给其它app使用，也可以自己定义操作权限，如只允许其它app读取自己的数据，而不允许修改等。CP的使用场景，是提供数据共享。CP本质上还是在操作数据库，数据存储在sdcard中，所以建立连接和操作数据都是耗时操作，所以注意开辟子线程去操作。当数据库中数据有变化时，Content Observer监听到数据库变化也是有一定的滞后。</p><h2 id="3、Broadcase方式（我们要避免使用这种通信方式）"><a href="#3、Broadcase方式（我们要避免使用这种通信方式）" class="headerlink" title="3、Broadcase方式（我们要避免使用这种通信方式）"></a>3、Broadcase方式（我们要避免使用这种通信方式）</h2><p>Broadcast使用非常简单，注册好广播，添加上action，就可以等着接收其他进程发出的广播。发送和接收广播时，还可以借助Intent来携带数据。但是广播的使用存在很多问题，被很多程序员吐槽，甚至鄙夷，所以选择用广播进行跨进程通信，是下下策。下面盘点一下Broadcast的槽点：</p><ol><li>Broadcast是一种单向的通信方式。当一个程序发送广播后，其他应用只能被动地接收，无法向发送者反馈。</li><li>Broadcast非常消耗系统资源，会导致系统性能下降。</li><li>速度慢，容易造成系统ANR。且除了Parall Broadcast外，无法保证接收到的时间，甚至不一定能收得到。</li><li>如果使用Ordered Broadcast，一个Receiver执行时间过长，会影响后面接收者的接收时间，甚至还有可能被中间某个Receiver拦截，导致后面Receiver无法接收到。</li><li>发送者无法确定谁会接收该广播，而接收者也无发确认是谁发来的广播</li><li>如果是静态注册的广播，一个没有开启的进程，都有可能被该广播激活。</li></ol><h2 id="4、Service方式"><a href="#4、Service方式" class="headerlink" title="4、Service方式"></a><strong>4、Service方式</strong></h2><p>普通的Service并不能实现跨进程操作，我们可以使用AIDL Service、LocalSocket来实现跨进程通信。</p><h2 id="AIDL-Service实现跨进程通信"><a href="#AIDL-Service实现跨进程通信" class="headerlink" title="AIDL Service实现跨进程通信"></a>AIDL Service实现跨进程通信</h2><p>这种方式也是 bindService() 启动方式的一种使用情况，也是广受程序员们推崇的方式。</p><ul><li><strong>如果跨进程需要界面上的交互操作，用隐式startActivity()方式实现。</strong></li><li><strong>如果需要共享数据，用Content Provider方式实现。</strong></li><li><strong>排除前两种情形，就用AIDL。</strong></li></ul><p>我们想要使用AIDL就要了解binder IPC 机制。（属于Android特殊的跨进程通信机制）</p>]]></content>
    
    
    <categories>
      
      <category>Android学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2023/02/16/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/16/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>​今天是我写博客的第一天，忙活了两天，终于搭建好了自己的博客，属于自己的私密空间。期待以后能够每天记录自己的日常。</p>]]></content>
    
    
    <categories>
      
      <category>日常生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
