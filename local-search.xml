<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>侯岩岩要求的中文博客</title>
    <link href="/2023/02/17/%E4%BE%AF%E5%B2%A9%E5%B2%A9%E8%A6%81%E6%B1%82%E7%9A%84%E4%B8%AD%E6%96%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/17/%E4%BE%AF%E5%B2%A9%E5%B2%A9%E8%A6%81%E6%B1%82%E7%9A%84%E4%B8%AD%E6%96%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="我是侯岩岩要求的中文博客"><a href="#我是侯岩岩要求的中文博客" class="headerlink" title="我是侯岩岩要求的中文博客"></a>我是侯岩岩要求的中文博客</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/17/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/02/17/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="传统-IPC-通信原理"><a href="#传统-IPC-通信原理" class="headerlink" title="传统 IPC 通信原理"></a>传统 IPC 通信原理</h1><p><strong>在操作系统中，进程与进程间的内存和数据都是不共享的</strong>。这样做的目的，是为了避免进程间相互操作数据的现象发生，从而引起各自的安全问题。为了实现进程隔离，采用了虚拟地址空间，两个进程各自的虚拟地址不同，从逻辑上来实现彼此间的隔离。两个进程之间要进行通信，就需要采用特殊的通信机制：进程间通信（IPC:Inter-Process Communication，即进程间通信或跨进程通信，简称 IPC）。</p><p><img src="https://img-blog.csdnimg.cn/5d182f4b99dc4edfa19e56c9a7ec7aef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>​一个进程空间分为用户空间和内核空间，用户空间是每个进程独有的，而内核空间则是所有进程间共有的。所以虽然不同进程的用户空间之间不能共享数据，但是我们可以通过内核空间来实现数据共享。</p><p>​数据在用户空间和内核空间之间的交互，需要调用系统方法：copy_from_user()和copy_to_user；数据拷贝2次，用户空间—&gt;&gt;内核空间—&gt;&gt;用户空间。</p><p><img src="https://img-blog.csdnimg.cn/1975c44081ee4b00a3f28fb157a3b34c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p><h1 id="Linux跨进程通信"><a href="#Linux跨进程通信" class="headerlink" title="Linux跨进程通信"></a>Linux跨进程通信</h1><p>Android系统就是基于Linux内核实现的，咱们先简单了解一下Linux系统的IPC方式。虽然不同的资料对各种方式的名称和种类说法不完全相同，但是主要来说有如下6种方式：（1）管道 Pipe；（2）信号Signal；（3）信号量Semaphore；（4）消息队列Message Queue；（5）共享内存Shared Memmory；（6）套接字Socket。</p><h1 id="Android跨进程通信"><a href="#Android跨进程通信" class="headerlink" title="Android跨进程通信"></a>Android跨进程通信</h1><p>Android 进程间通信可以通过Android 四大组件实现。</p><h2 id="1、Activity方式"><a href="#1、Activity方式" class="headerlink" title="1、Activity方式"></a>1、Activity方式</h2><p>Activity是四大组件中使用最频繁的，咱们先从它说起。使用Activity方式实现，就是使用startActivity()来启动另外一个进程的Activity。我们在使用App的使用，往往会遇到如下几种情形：</p><p>（1）浏览器中看到一篇比较不错的文章，分享到微信朋友圈或者微博；</p><p>（2）在某个App中点击某个网址，然后界面跳转到浏览器中进行阅读；</p><p>（3）使用美团外卖app，看到店家的电话，点击联系商家时，跳转到了电话拨打界面…</p><p>这些就是通过startActivity的方式从一个App，跳转到了另外一个App的Activity，从而实现了跨进程通信。</p><p>我们知道，在调用startActivity(Intent intent)的时候，intent有两个类型：显式Intent和隐式Intent。</p><p><strong>显式Intent的使用方式如下，用于进程内组件间通信</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,OtherActivity.class);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><p><strong>隐式intent的使用方式如下，用于IPC</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.setAction(Intent.ACTION_CALL);<br>startActivity(intent); <span class="hljs-comment">//startActivityForResult()同样，这里不赘述</span><br><br></code></pre></td></tr></table></figure><p>Intent.ACTION_CALL就是字符串常量“android.intent.action.CALL”，这种方式通过setAction的方式来启动目标app的Activity，上述代码就是启动电话app的拨号界面，有时候还可以带上电话号码等参数。由上可知，Activity实现跨进程通信的方式，适合于不同App之间功能界面的跳转。</p><h2 id="2、Content-provider（后面简称CP）方式"><a href="#2、Content-provider（后面简称CP）方式" class="headerlink" title="2、Content provider（后面简称CP）方式"></a>2、Content provider（后面简称CP）方式</h2><p>当我们开发App需要用到联系人，多媒体信息等数据的时候，往往会通过系统提供Uri，采用CP的方式去获取。Android系统中，数据主要存储在自带的SqlLite数据库中。应用要共享SqlLite中的数据给其他App操作（增、删、改、查），就要用到CP，也就是说，CP主要用于跨进程数据库共享。Android系统提供了很多的CP来供其它App使用，如多媒体信息、联系人、日历等。如下图显示了Android系统提供的CP，包名都是以”com.android.providers“开头的：</p><p>App开发者也可以自定义CP，把自己的数据提供给其它app使用，也可以自己定义操作权限，如只允许其它app读取自己的数据，而不允许修改等。CP的使用场景，是提供数据共享。CP本质上还是在操作数据库，数据存储在sdcard中，所以建立连接和操作数据都是耗时操作，所以注意开辟子线程去操作。当数据库中数据有变化时，Content Observer监听到数据库变化也是有一定的滞后。</p><h2 id="3、Broadcase方式（我们要避免使用这种通信方式）"><a href="#3、Broadcase方式（我们要避免使用这种通信方式）" class="headerlink" title="3、Broadcase方式（我们要避免使用这种通信方式）"></a>3、Broadcase方式（我们要避免使用这种通信方式）</h2><p>Broadcast使用非常简单，注册好广播，添加上action，就可以等着接收其他进程发出的广播。发送和接收广播时，还可以借助Intent来携带数据。但是广播的使用存在很多问题，被很多程序员吐槽，甚至鄙夷，所以选择用广播进行跨进程通信，是下下策。下面盘点一下Broadcast的槽点：</p><ol><li>Broadcast是一种单向的通信方式。当一个程序发送广播后，其他应用只能被动地接收，无法向发送者反馈。</li><li>Broadcast非常消耗系统资源，会导致系统性能下降。</li><li>速度慢，容易造成系统ANR。且除了Parall Broadcast外，无法保证接收到的时间，甚至不一定能收得到。</li><li>如果使用Ordered Broadcast，一个Receiver执行时间过长，会影响后面接收者的接收时间，甚至还有可能被中间某个Receiver拦截，导致后面Receiver无法接收到。</li><li>发送者无法确定谁会接收该广播，而接收者也无发确认是谁发来的广播</li><li>如果是静态注册的广播，一个没有开启的进程，都有可能被该广播激活。</li></ol><h2 id="4、Service方式"><a href="#4、Service方式" class="headerlink" title="4、Service方式"></a><strong>4、Service方式</strong></h2><p>普通的Service并不能实现跨进程操作，我们可以使用AIDL Service、LocalSocket来实现跨进程通信。</p><h2 id="AIDL-Service实现跨进程通信"><a href="#AIDL-Service实现跨进程通信" class="headerlink" title="AIDL Service实现跨进程通信"></a>AIDL Service实现跨进程通信</h2><p>这种方式也是 bindService() 启动方式的一种使用情况，也是广受程序员们推崇的方式。</p><ul><li><strong>如果跨进程需要界面上的交互操作，用隐式startActivity()方式实现。</strong></li><li><strong>如果需要共享数据，用Content Provider方式实现。</strong></li><li><strong>排除前两种情形，就用AIDL。</strong></li></ul><p>我们想要使用AIDL就要了解binder IPC 机制。（属于Android特殊的跨进程通信机制）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2023/02/16/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/16/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
